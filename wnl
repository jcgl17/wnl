#!/bin/bash

load_rc_file() {
	# shellcheck disable=SC1090
	test -f "$RC_FILE" && source "$RC_FILE"
}

### CONFIGURATION {{
RC_FILE=${RC_FILE:-${XDG_CONFIG_HOME:-$HOME/.config}/wnl/wnlrc}
load_rc_file
EXIT_AFTER_NONZERO=${EXIT_AFTER_NONZERO:-0}
SHELL_CMD=${SHELL_CMD:-"$SHELL -c"}
HOOK_PRE=${HOOK_PRE:-}
HOOK_POST=${HOOK_POST:-}
HOOK_STARTUP=${HOOK_STARTUP:-}
HOOK_EXIT=${HOOK_EXIT:-}
BANNER_PRE_ENABLE=${BANNER_PRE_ENABLE:-1}
BANNER_POST_ENABLE=${BANNER_POST_ENABLE:-1}
SHELL_INTEGRATION_ENABLE=${SHELL_INTEGRATION_ENABLE:-1}
AUTOSLOT_MAX=${AUTOSLOT_MAX:-10}
RUNTIME_DIR=${RUNTIME_DIR:-${XDG_RUNTIME_DIR:-/tmp}}
### }} CONFIGURATION

diff_time() {
	t1=$(date -d "$1" +%s 2>/dev/null) || { echo "Bad date: $1" >&2; return 1; }
	t2=$(date -d "$2" +%s 2>/dev/null) || { echo "Bad date: $2" >&2; return 1; }

	# it turns out that arithmetic in bash can do cool things like assignment and ternaries
	# https://www.gnu.org/software/bash/manual/html_node/Shell-Arithmetic.html
	# "ARITHMETIC EVALUATION" section in bash manpage
	(( delta = t1 > t2 ? t1 - t2 : t2 - t1 ))
	(( days = delta / 86400, delta %= 86400 ))
	(( hours = delta / 3600, delta %= 3600  ))
	(( mins = delta / 60, secs  = delta % 60 ))

	if [ "$days" -gt 0 ]; then
		printf "%d:%02d:%02d:%02d\n" "$days" "$hours" "$mins" "$secs"
	elif [ "$hours" -gt 0 ]; then
		printf "%d:%02d:%02d\n" "$hours" "$mins" "$secs"
	else
		printf "%d:%02d\n" "$mins" "$secs"
	fi
}

banner_pre() {
	START_TIME=$(date +%X)
	test "$BANNER_PRE_ENABLE" -eq "0" && return
	bracket_color="${FMT_GREEN}"
	echo "${bracket_color}[[ ${FMT_NORMAL}${FMT_GREY}running${FMT_NORMAL} $(cmd_title) ${FMT_GREY}at${FMT_NORMAL} ${START_TIME} ${FMT_GREY}in slot${FMT_NORMAL} $SLOT ${bracket_color}]]${FMT_NORMAL}"
}

banner_post() {
	STOP_TIME=$(date +%X)
	test "$BANNER_POST_ENABLE" -eq "0" && return
	if [ "$EXIT_CODE" -ne 0 ]; then
		bracket_color="${FMT_RED}"
		exit_code_color="${FMT_RED}${FMT_BOLD}"
	else
		bracket_color="${FMT_GREEN}"
		exit_code_color="${FMT_NORMAL}"
	fi
	shell_integrations_prompt_start
	echo "${bracket_color}[[ ${FMT_NORMAL}${FMT_GREY}finished ${FMT_NORMAL}$(cmd_title)${FMT_GREY} with exit code ${exit_code_color}${EXIT_CODE}${FMT_NORMAL} ${FMT_GREY}at${FMT_NORMAL} ${STOP_TIME}(+$(diff_time "$START_TIME" "$STOP_TIME")) ${FMT_GREY}in slot${FMT_NORMAL} $SLOT ${bracket_color}]]${FMT_NORMAL}"
	if [ "$EXIT_CODE" -ne "0" ] && [ "$EXIT_AFTER_NONZERO" -ne "0" ]; then
		exit "$EXIT_CODE"
	fi
}

hook_pre() {
	test -n "$HOOK_PRE"     && ( $SHELL_CMD "$HOOK_PRE"     || echo HOOK_PRE     exited with code $?. continuing. )
}

hook_post() {
	test -n "$HOOK_POST"    && ( $SHELL_CMD "$HOOK_POST"    || echo HOOK_POST    exited with code $?. continuing. )
}

hook_startup() {
	test -n "$HOOK_STARTUP" && ( $SHELL_CMD "$HOOK_STARTUP" || echo HOOK_STARTUP exited with code $?. continuing. )
}

hook_exit() {
	test -n "$HOOK_EXIT"    && ( $SHELL_CMD "$HOOK_EXIT"    || echo HOOK_EXIT    exited with code $?. continuing. )
}

shell_integrations_cmd_start() {
	test "$SHELL_INTEGRATION_ENABLE" -ne "0" && echo -ne "$SHELL_INTEGRATION_CMD_START"
}

shell_integrations_prompt_start() {
	test "$SHELL_INTEGRATION_ENABLE" -ne "0" && echo -ne "$SHELL_INTEGRATION_PROMPT_START"
}

cmd_title() {
	# 63 is roughly the width of the banner_post (which in longer than banner_pre), minus CMD_TITLE
	CMD_TITLE_MAXLENGTH=$(("$(tput cols)" - 63))
	test $CMD_TITLE_MAXLENGTH -lt 10 && CMD_TITLE_MAXLENGTH=10
	excess_title_length="$(("${#CMD_RAW}" - "${CMD_TITLE_MAXLENGTH}"))"
	if [ "${excess_title_length}" -gt "1" ]; then
		trim_head="${CMD_RAW:0:$(("$CMD_TITLE_MAXLENGTH"/2))}"
		trim_tail="${CMD_RAW:$(("${#CMD}"-("$CMD_TITLE_MAXLENGTH"/2))):"${#CMD}"}"
			CMD_TITLE="${trim_head}…${trim_tail}"
		else
			CMD_TITLE="$CMD_RAW"
	fi
	echo "$CMD_TITLE"
}

# kill_signal decides what signal should be sent to kill RUNNING_CMD
kill_signal() {
	cmd=$1
	# if user has specified a kill signal, user that
	if [ -n "$KILL_SIGNAL" ]; then
		echo "$KILL_SIGNAL"
		return 0
	fi
	# otherwise, fall back on heuristics
	if [[ "$cmd" =~ ^[a-zA-Z]*sh\ -c ]]; then
		echo TERM
	elif [[ "$cmd" =~ ^make( |$)  ]]; then
		echo TERM
	else
		echo INT
	fi
}

handle_usr1() {
	SIGNAL_START=1
}

handle_usr2(){
	SIGNAL_STOP=1
}

handle_exit() {
	# echo removing pidfile
	rm -f "$PIDFILE"
	test -n "$SLP_PID" && kill "$SLP_PID"
	hook_exit
}

trap handle_usr1 SIGUSR1
trap handle_usr2 SIGUSR2
trap handle_exit EXIT

pidfile() {
	local slot=$1
	mkdir -p "${RUNTIME_DIR}"
	echo "${RUNTIME_DIR}/wnl_slot_${slot}.pid"
}

function take_lock() {
	local slot=$1
	# shellcheck disable=SC2155
	local pidfile_to_lock="$(pidfile "$slot")"
	if [ ! -f "$pidfile_to_lock" ]; then
		exec 17<>"$pidfile_to_lock"
		if ! flock -n -x 17; then
			return 2
		fi
		echo $$ > "$pidfile_to_lock"
		PIDFILE=$(pidfile "$SLOT")
	else
		return 1
	fi
}

### ARG PARSING {{
# check if $1 is a number
if [ -n "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null; then
	# if it is, then use it as the slot
	SLOT=$1
	# and then shift (remove $1 from args) to have the rest turn into CMD
	shift
	take_lock "$SLOT" || ( echo "Error: unable to acquire lock on $(pidfile "$SLOT")" >&2 && exit 1 )
else
	# otherwise, find the first available slot
	AUTOSLOT=1
	for ((i=1; i <= "$AUTOSLOT_MAX"; i++)); do
		SLOT=$i
		take_lock "$SLOT" && break
	done
	if [ -z "$SLOT" ]; then
		echo Error: unable to find an available slot
		exit 1
	fi
fi
export SLOT

# escape command to preserve user-provided as faithfully as possible
CMD=$(printf "%q " "$@")
CMD_RAW="$*"
# remove trailing space
CMD="${CMD%" "}"
### }} ARG PARSING

### CONSTANTS {{
# https://sw.kovidgoyal.net/kitty/shell-integration/#notes-for-shell-developers
SHELL_INTEGRATION_PROMPT_START='\x1b\x5d133;A\x1b\x5c'
SHELL_INTEGRATION_CMD_START='\x1b\x5d133;C\x1b\x5c'

# stop_signal/SIGUSR2 handling relies on identifying the process being run
# ($RUNNING_CMD). standard shells (e.g. bash) when called with `-c` do an
# immediate `exec`. The pid can then easily be found with `RUNNING_CMD=$!`.
#
# However, fish does a `fork` then `exec`. So pgrepping for the child process
# would becomes necessary. The fish devs are aware of this difference in
# behavior, but will not fix:
# https://github.com/fish-shell/fish-shell/issues/6902
#
# So the workaround is to insert a little `exec` into the command whenever fish
# is the shell in use ¯\_(ツ)_/¯
if [[ "$SHELL_CMD" =~ .*fish\ -c ]]; then
	EXEC_IF_FISH="exec "
else
	EXEC_IF_FISH=""
fi
### }} CONSTANTS

# define colors
# https://unix.stackexchange.com/a/10065
if test -t 1; then
	# see if it supports colors...
	ncolors=$(tput colors)
	if test -n "$ncolors" && test "$ncolors" -ge 8; then
		FMT_BOLD="$(tput bold)"; export FMT_BOLD
		FMT_UNDERLINE="$(tput smul)"; export FMT_UNDERLINE
		FMT_STANDOUT="$(tput smso)"; export FMT_STANDOUT
		FMT_NORMAL="$(tput sgr0)"; export FMT_NORMAL
		FMT_BLACK="$(tput setaf 0)"; export FMT_BLACK
		FMT_RED="$(tput setaf 1)"; export FMT_RED
		FMT_GREEN="$(tput setaf 2)"; export FMT_GREEN
		FMT_YELLOW="$(tput setaf 3)"; export FMT_YELLOW
		FMT_BLUE="$(tput setaf 4)"; export FMT_BLUE
		FMT_MAGENTA="$(tput setaf 5)"; export FMT_MAGENTA
		FMT_CYAN="$(tput setaf 6)"; export FMT_CYAN
		FMT_WHITE="$(tput setaf 7)"; export FMT_WHITE
		FMT_GREY="$(tput setaf 8)"; export FMT_GREY
	fi
fi

## MAIN {{
test -n "$AUTOSLOT" && echo wnl starting with slot "$SLOT"

sleep infinity &
SLP_PID=$!
SIGNAL_START=0
SIGNAL_STOP=0
hook_startup
while true; do 
	# reload rc file every run
	load_rc_file
	# echo eval state begin: SIGNAL_STOP: $SIGNAL_STOP, SIGNAL_START: $SIGNAL_START, RUNNING_CMD: $RUNNING_CMD, IS_RUNNING: "$([ -v RUNNING_CMD ] && kill -0 "$RUNNING_CMD" 2>/dev/null && echo yes || echo no)"
	if [ "$SIGNAL_STOP" -eq "1" ]; then
		# if RUNNING_CMD is defined and it's running, then kill it
		if [ -v RUNNING_CMD ] && kill -0 "$RUNNING_CMD" 2>/dev/null; then
			kill -"$(kill_signal "$CMD_RAW")" "$RUNNING_CMD"
			wait -n "$RUNNING_CMD"
			# export EXIT_CODE for consumption by hook
			export EXIT_CODE=$?
			if ! kill -0 "$RUNNING_CMD" 2>/dev/null; then
				banner_post
				hook_post
			fi
		fi
	elif [ "$SIGNAL_START" -eq 1 ]; then
		# if RUNNING_CMD is not defined or it's not running, then start it
		if ! [ -v RUNNING_CMD ] || ! kill -0 "$RUNNING_CMD" 2>/dev/null; then
			banner_pre
			hook_pre
			shell_integrations_cmd_start
			(
				# this `set -m` crucially enables job control for this backgrounded subshell.
				# without it, SIGINT handling doesn't work.
				set -m
				exec $SHELL_CMD "$EXEC_IF_FISH${CMD}" >&1 2>&2
			) &
			RUNNING_CMD=$!
		fi
	fi
	SIGNAL_START=0
	SIGNAL_STOP=0
	# echo eval state end: SIGNAL_STOP: $SIGNAL_STOP, SIGNAL_START: $SIGNAL_START, RUNNING_CMD: $RUNNING_CMD, IS_RUNNING: "$([ -v RUNNING_CMD ] && kill -0 "$RUNNING_CMD" 2>/dev/null && echo yes || echo no)"
	if [ -v RUNNING_CMD ] && kill -0 "$RUNNING_CMD" 2>/dev/null; then
		wait -n "$RUNNING_CMD"
		# export EXIT_CODE for consumption by hook
		export EXIT_CODE=$?
		# only summarize if RUNNING_CMD is done, i.e. that the wait wasn't just interrupted to handle a signal
		if ! kill -0 "$RUNNING_CMD" 2>/dev/null; then
			banner_post
			hook_post
		fi
	else
		wait
	fi
	# restart infinite sleep, just in case it got killed somehow (e.g. by the user)
	if ! kill -0 "$SLP_PID" 2>/dev/null; then
		sleep infinity &
		SLP_PID=$!
	fi
done
## }} MAIN
