#!/bin/bash

### ARG PARSING {{
# check if $1 is a number
if [ -n "$1" ] && [ "$1" -eq "$1" ] 2>/dev/null; then
	# if it is, then use it as the slot
	SLOT=$1
	# and then shift (remove $1 from args) to have the rest turn into CMD
	shift
else
	# otherwise, default to 1 as the slot
	SLOT=1
fi

CMD="$*"
# cut is needed--the user may have quoted their CMD.
# that makes the entire CMD as $1--not just its first space-delimited word
CMD_NAME=$(echo "$1" | cut -f1 -d' ')
### }} ARG PARSING

RC_FILE="${RC_FILE:-${XDG_CONFIG_HOME:-$HOME/.config}/wnl/wnlrc}"


load_rc_file() {
	# shellcheck disable=SC1090
	test -f "$RC_FILE" && source "$RC_FILE"
}

### CONFIGURATION {{
EXIT_AFTER_NONZERO=0
SHELL_CMD="$SHELL -c"
HOOK_PRE=
HOOK_POST=
BANNER_PRE_ENABLE=1
BANNER_POST_ENABLE=1
SHELL_INTEGRATION_ENABLE=1
load_rc_file
### }} CONFIGURATION

### CONSTANTS {{
PIDFILE="${XDG_RUNTIME_DIR:?XDG_RUNTIME_DIR not set}/wnl_slot_${SLOT}.pid"
# https://sw.kovidgoyal.net/kitty/shell-integration/#notes-for-shell-developers
SHELL_INTEGRATION_PROMPT_START='\x1b\x5d133;A\x1b\x5c'
SHELL_INTEGRATION_CMD_START='\x1b\x5d133;C\x1b\x5c'
### }} CONSTANTS

# define colors
# https://unix.stackexchange.com/a/10065
if test -t 1; then
    # see if it supports colors...
    ncolors=$(tput colors)
    if test -n "$ncolors" && test "$ncolors" -ge 8; then
        bold="$(tput bold)"
        underline="$(tput smul)"
        standout="$(tput smso)"
        normal="$(tput sgr0)"
        black="$(tput setaf 0)"
        red="$(tput setaf 1)"
        green="$(tput setaf 2)"
        yellow="$(tput setaf 3)"
        blue="$(tput setaf 4)"
        magenta="$(tput setaf 5)"
        cyan="$(tput setaf 6)"
        white="$(tput setaf 7)"
    fi
fi

handle_usr1() {
	SIGNAL_START=1
}

handle_usr2(){
	SIGNAL_STOP=1
}

handle_exit() {
	# echo removing pidfile
	rm -f "$PIDFILE"
	kill "$SLP_PID"
}

trap handle_usr1 SIGUSR1
trap handle_usr2 SIGUSR2
trap handle_exit EXIT

banner_pre() {
	test "$BANNER_PRE_ENABLE" -eq "0" && return
	bracket_color="${cyan}"
	echo "${bracket_color}[[ ${normal}running ${CMD_NAME} at $(date +%X) ${bracket_color}]]${normal}"
}

banner_post() {
	test "$BANNER_POST_ENABLE" -eq "0" && return
	if [ "$EXIT_CODE" -ne 0 ]; then
		bracket_color="${red}"
		exit_code_color="${red}${bold}"
	else
		bracket_color="${cyan}"
		exit_code_color="${normal}"
	fi
	shell_integrations_prompt_start
	echo "${bracket_color}[[ ${normal}finished with exit code ${exit_code_color}${EXIT_CODE}${normal} at $(date +%X) ${bracket_color}]]${normal}"
	if [ "$EXIT_CODE" -ne "0" ] && [ "$EXIT_AFTER_NONZERO" -ne "0" ]; then
		exit "$EXIT_CODE"
	fi
}

hook_pre() {
	test -n "$HOOK_PRE" && $SHELL_CMD "$HOOK_PRE"
}

hook_post() {
	test -n "$HOOK_POST" && $SHELL_CMD "$HOOK_POST"
}

shell_integrations_cmd_start() {
	test "$SHELL_INTEGRATION_ENABLE" -ne "0" && echo -ne "$SHELL_INTEGRATION_CMD_START"
}

shell_integrations_prompt_start() {
	test "$SHELL_INTEGRATION_ENABLE" -ne "0" && echo -ne "$SHELL_INTEGRATION_PROMPT_START"
}

## MAIN {{
# make pidfile with locking
exec 17>>"$PIDFILE"
if ! flock -n -x 17; then
    echo "Error: unable to acquire lock on $PIDFILE" >&2
    exit 1
fi
echo $$ > "$PIDFILE"

sleep infinity &
SLP_PID=$!
SIGNAL_START=0
SIGNAL_STOP=0
while true; do 
	# reload rc file every run
	load_rc_file
	# echo eval state begin: SIGNAL_STOP: $SIGNAL_STOP, SIGNAL_START: $SIGNAL_START, RUNNING_CMD: $RUNNING_CMD, IS_RUNNING: "$([ -v RUNNING_CMD ] && kill -0 "$RUNNING_CMD" 2>/dev/null && echo yes || echo no)"
	if [ "$SIGNAL_STOP" -eq "1" ]; then
		# if RUNNING_CMD is defined and it's running, then kill it
		if [ -v RUNNING_CMD ] && kill -0 "$RUNNING_CMD" 2>/dev/null; then
			# Kill the actual process the user specified, rather than trying to kill the shell 
			# _running_ that command.
			# kill -INT "$RUNNING_CMD"
			SHELL_CHILD=$(pgrep -P "$RUNNING_CMD")
			if [ -n "$SHELL_CHILD" ]; then
				kill -INT "$SHELL_CHILD"
			fi
			wait -n "$RUNNING_CMD"
			# export EXIT_CODE for consumption by hook
			export EXIT_CODE=$?
			if ! kill -0 "$RUNNING_CMD" 2>/dev/null; then
				banner_post
				hook_post
			fi
		fi
	elif [ "$SIGNAL_START" -eq 1 ]; then
		# if RUNNING_CMD is not defined or it's not running, then start it
		if ! [ -v RUNNING_CMD ] || ! kill -0 "$RUNNING_CMD" 2>/dev/null; then
			banner_pre
			hook_pre
			shell_integrations_cmd_start
			$SHELL_CMD "$CMD" >&1 2>&2 &
			RUNNING_CMD=$!
		fi
	fi
	SIGNAL_START=0
	SIGNAL_STOP=0
	# echo eval state end: SIGNAL_STOP: $SIGNAL_STOP, SIGNAL_START: $SIGNAL_START, RUNNING_CMD: $RUNNING_CMD, IS_RUNNING: "$([ -v RUNNING_CMD ] && kill -0 "$RUNNING_CMD" 2>/dev/null && echo yes || echo no)"
	if [ -v RUNNING_CMD ] && kill -0 "$RUNNING_CMD" 2>/dev/null; then
		wait -n "$RUNNING_CMD"
		# export EXIT_CODE for consumption by hook
		export EXIT_CODE=$?
		# only summarize if RUNNING_CMD is done, i.e. that the wait wasn't just interrupted to handle a signal
		if ! kill -0 "$RUNNING_CMD" 2>/dev/null; then
			banner_post
			hook_post
		fi
	else
		wait
	fi
	# restart infinite sleep, just in case it got killed somehow (e.g. by the user)
	if ! kill -0 "$SLP_PID" 2>/dev/null; then
		sleep infinity &
		SLP_PID=$!
	fi
done
## }} MAIN
