= wnl(1)
:doctype: manpage
:manmanual: WNL
:mansource: WNL
:man-linkstyle: pass:[blue R < >]

== Name

wnl - Wait `n` Listen: bind a command in one shell, and trigger it on-demand from anywhere

== Synopsis

*wnl* [_SLOT_ID_] _COMMAND_ [_COMMAND_ARGUMENTS_...]

*wnl* [_SLOT_ID_] ssh [_REMOTE_SLOT_ID_] _SSH_REMOTE_HOST_ [_COMMAND_ [_COMMAND_ARGUMENTS_...]]

*wnlctl* [_SLOT_ID_]

== Description

wnl helps create a "Unix as IDE" workflow.
You bind a frequently-run command with *wnl*, then trigger it from anywhere with *wnlctl*.
Optionally configure a hotkey in your desktop environment, and you have keyboard shortcuts for ad-hoc shell commands.

For example:

. Bind a command (_COMMAND_) to _SLOT_ID_ 1 in one shell with wnl: +
`$ wnl 1 make test`
. (repeatedly) Trigger _COMMAND_ by calling wnlctl from another shell: +
`$ wnlctl 1`
Or bind wnlctl 1 to a keyboard shortcut with your desktop environment.
. (optional) Interrupt _COMMAND_ with wnlctl: +
`$ SIGNAL=USR2 wnlctl 1`
. When you're done with this command, un-bind it by exiting wnl with Ctrl-c

While _COMMAND_ is running, repeated calls to wnlctl do nothing. When _COMMAND_ is not running, wnl will sit and wait until wnlctl triggers it again.

== Slots

A "slot" (specified with `SLOT++_++ID`) represents a single instance
of `wnl`. This allows for multiple, separate commands to be bound:

[source,command]
----
# running two instances in subshells, just to keep this example concise
$ (wnl 1 echo hi from slot 1! &); (wnl 2 echo hi from slot 2! &)
$ wnlctl 1; wnlctl 2
[[ running echo hi from slot 1! at 10:12:29 in slot 1 ]]
[[ running echo hi from slot 2! at 10:12:29 in slot 2 ]]
hi from slot 1!
hi from slot 2!
[[ finished echo hi from slot 1! with exit code 0 at 10:12:29 in slot 1 ]]
[[ finished echo hi from slot 2! with exit code 0 at 10:12:29 in slot 2 ]]
----

== SSH Mode

The ssh syntax shown above allows you to use `wnlctl` locally to trigger
an instance of wnl running on a remote host. An interactive SSH session
will be opened to the host specified in SSH++_++REMOTE++_++HOST. _wnl
must already be installed on the remote host._

If _COMMAND_ is specified, `wnl` will immediately be started on the remote
host, ready to be triggered by your local calls to `wnlctl`.

[source,command]
----
user@localhost:~$ wnl ssh remotehost.example.com make test
wnl starting with slot 1
wnl starting with slot 1 on remotehost
----

If COMMAND is not specified, `wnl` will not be started and you’ll be
given a normal, interactive SSH session. You will have to manually run
`wnl ++[++REMOTE++_++SLOT++_++ID++]++ COMMAND`. Instructions to that
effect will be printed by `wnl` before opening the SSH session.

[source,command]
----
# you'd rarely want to manually specify REMOTE_SLOT_ID (3 here),
# but it's an option
user@localhost:~$ wnl 2 ssh 3 remotehost.example.com
wnl starting with slot 2
enter in 'wnl 3 <yourcommand>'
user@remotehost:~$ wnl 3 echo hi on a remote host!
# you trigger slot 2 with wnlctl on your local machine
hi on a remote host!
----

== Options

*SLOT++_++ID*::
Numeric identifier of the slot. `wnl` defaults to the first unused slot (counting up from 1). `wnlctl` defaults to slot 1.

*REMOTE++_++SLOT++_++ID*::
In SSH mode, numeric identifier of the slot used on the remote host. By default, it is the same as `SLOT++_++ID`.

== Environment

*SIGNAL*::
Used with `wnl` and `wnlctl`. +
+
With `wnlctl`, this controls what message is sent to `wnl`. `USR1` tells
`wnl` to start command execution, and `USR2` tells `wnl` to terminate
execution. Defaults to `USR1`. +
+
With `wnl`, this controls what signal is sent to a running instance of
COMMMAND when instructed by `wnlctl` to terminate execution. Defaults to
`INT`.

*DOUBLE++_++TAP++_++REQUIRED*::
Used with `wnl`.
If true, two signals from `wnlctl` are required before triggering `COMMAND`.
Choose `true` or `false`. Defaults to `false`.

*RESTART++_++MODE*::
Used with `wnl`. If true, a trigger from `wnlctl` while `COMMAND` is already running will restart `COMMAND`.
Choose `true` or `false`. Defaults to `false`.

*STOPSTART++_++MODE*::
Used with `wnl`.
If true, a trigger from `wnlctl` while `COMMAND` is already running will stop `COMMAND`, and a trigger while `COMMAND` is not running will start it.
Choose `true` or `false`. Defaults to `false`. +
+
Mutually exclusive with *RESTART++_++MODE*

== Files

User configuration file: `~/.config/wnl/wnlrc`

The only interesting things to configure are hooks. Hooks are shell
snippets that are executed at various points in wnl’s lifecycle:

[width="100%",cols="12%,88%",options="header",]
|===
|Name |Description
|`HOOK++_++STARTUP` |Run once when `wnl` starts

|`HOOK++_++EXIT` |Run once when `wnl` exits (after you hit Ctrl-c)

|`HOOK++_++PRE` |Run just before each invocation of `COMMAND`

|`HOOK++_++POST` |Run just after each invocation of `COMMAND`. The
variable `EXIT++_++CODE` contains the command’s exit status.
|===

Example `wnlrc`:

[source,bash]
----
# Play a gentle tone whenever wnl is triggered
HOOK_PRE='pw-play /usr/share/sounds/ocean/stereo/service-logout.oga &'
# Play a an alert whenever the command run by wnl fails with a nonzero exit code
# $EXIT_CODE is set to the exit code from the now-finished command
HOOK_POST='test "$EXIT_CODE" -eq 0 || pw-play /usr/share/sounds/oxygen/stereo/message-connectivity-error.ogg &'
# ANSI color/formatting codes are available in $FMT_* variables
HOOK_EXIT='echo "$FMT_GREEN$FMT_BOLD"; cowsay thanks for using wnl; echo "$FMT_NORMAL"'
----

== Examples
. Run tests in the next free slot: +
`$ wnl make test`
. Trigger slot 1 (for example, bound to Ctrl-F1 in your desktop environment): +
`$ wnlctl 1`
. Abort the command in slot 1 (for example, bound to Ctrl-Shift-F1 in your desktop environment): +
`$ SIGNAL=USR2 wnlctl 1`

== See Also
entr(1) - another Unix-as-IDE tool that (re-)runs commands after file changes

== Bugs

Report bugs at https://codeberg.org/jcgl/wnl/issues or email j+wnl@cgl.sh
