.Dd 2025-06-11
.Dt WNL 1
.Os

.Sh NAME
.Nm wnl
.Nd Wait 'n' Listen: bind a command in one shell, and trigger it on-demand from anywhere

.Sh SYNOPSIS
.Nm wnl
.Op Ar SLOT_ID
.Ar COMMAND
.Op Ar COMMAND_ARGUMENTS...
.Nm wnlctl
.Op Ar SLOT_ID

.Sh DESCRIPTION
.Nm wnl
helps create a "Unix as IDE" workflow: you bind a frequently-run command with
.Nm wnl\c ,
then trigger it from anywhere with
.Nm wnlctl\c .

.Pp
For example:
.Bl -enum
.It
Bind a command (\c
.Ar COMMAND\c )
to
.Ar SLOT_ID
.Cm 1
in one shell with
.Nm wnl
.Dl $ wnl 1 make test

.It
(repeatedly) Trigger 
.Ar COMMAND
by calling
.Nm wnlctl
from another shell
.Dl $ wnlctl 1
.Pp
Or bind
.Cm wnlctl 1
to a keyboard shortcut within your Desktop Environment.

.It
(optional) Interrupt
.Ar COMMAND
with
.Nm wnlctl
.Dl $ SIGNAL=USR2 wnlctl 1

.It
When you're done with this command, un-bind it by exiting
.Nm wnl
with
.Cm Ctrl-c
.El

.Pp
While
.Ar COMMAND
is running, repeated calls to
.Nm wnlctl
do nothing. When
.Ar COMMAND is not running,
.Nm wnl
will sit and wait until
.Nm wnlctl
triggers it again.

.Pp
A "slot" (specified with 
.Ar SLOT_ID\c )
represents a single instance of
.Nm wnl\c .
This allows for multiple, separate commands to be bound:
.Bd -literal -offset Ds
# running two instances in subshells, just to keep this example concise
$ (wnl 1 sh -c 'for i in once twice; do echo slot 1 says hello $i!; sleep 1; done' &)
$ (wnl 2 sh -c 'for i in once twice; do echo slot 2 says hello $i!; sleep 1; done' &)
$ wnlctl 1; wnlctl 2
[[ running sh -c for i in once twice; do echo slot 1 says hello $i!; sleep 1; done at 17:32:18 in slot 1 ]]
[[ running sh -c for i in once twice; do echo slot 2 says hello $i!; sleep 1; done at 17:32:18 in slot 2 ]]
slot 1 says hello once!
slot 2 says hello once!
slot 1 says hello twice!
slot 2 says hello twice!
[[ finished sh -c for i in once twice; do echo slot 1 says hello $i!; sleep 1; done with exit code 0 at 17:32:20 in slot 1 ]]
[[ finished sh -c for i in once twice; do echo slot 2 says hello $i!; sleep 1; done with exit code 0 at 17:32:20 in slot 2 ]]
.Ed

.Sh OPTIONS
.Bl -tag -width
.It Ar SLOT_ID
Numeric identifier of the slot. If omitted,
.Nm wnl
picks the first free slot (counting up from 1).
.Nm wnlctl
defaults to slot 1.
.El

.Sh ENVIRONMENT
.Bl -tag -width "SIGNAL"
.It Ev SIGNAL
Signal that is used to communicate with
.Nm wnl\c .
Either
.Cm USR1
to tell 
.Nm wnl
to start command execution, or
.Cm USR2
to tell
.Nm wnl
to terminate execution.

.Cm USR1
is sent if this is not specified.
.El

.Sh FILES
User configuration file:
.Pa ~/.config/wnl/wnlrc

The only interesting things to configure are hooks. Hooks are shell snippets that are executed at various points in wnl's lifecycle:

.Bl -tag
.It Cm HOOK_STARTUP
Run once when
.Nm wnl
starts

.It Cm HOOK_PRE
Run just before each invocation of
.Ar COMMAND

.It Cm HOOK_POST
Run just after each invocation of
.Ar COMMAND\c .
The variable
.Va EXIT_CODE
contains the command’s exit status.

.It Cm HOOK_EXIT
Run once when
.Nm wnl
exits (after you hit Ctrl-c)
.El

Example
.Fa wnlrc :
.Bd -literal -offset Ds
# Play a gentle tone whenever wnl is triggered
HOOK_PRE='pw-play /usr/share/sounds/ocean/stereo/service-logout.oga &'
# Play a an alert whenever the command run by wnl fails with a nonzero exit code
# $EXIT_CODE is set to the exit code from the now-finished command
HOOK_POST='test "$EXIT_CODE" -eq 0 || pw-play /usr/share/sounds/oxygen/stereo/message-connectivity-error.ogg &'
# ANSI color/formatting codes are available in $FMT_* variables
HOOK_EXIT='echo "$FMT_GREEN$FMT_BOLD"; cowsay thanks for using wnl; echo "$FMT_NORMAL"'
.Ed

.Sh EXAMPLES
.Bl -enum
.It
Run tests in the next free slot:
.Dl $ wnl make test

.It
Trigger slot 1 (for example, bound to Ctrl-F1 in your Desktop Environment):
.Dl $ wnlctl 1

.It
Abort the command in slot 1 (for example, bound to Ctrl-Shift-F1 in your Desktop Environment):
.Dl $ SIGNAL=USR2 wnlctl 1
.El

.Sh SEE ALSO
.Xr entr 1
— another Unix-as-IDE tool

.Sh BUGS
Report bugs at
.Li https://codeberg.org/jcgl/wnl/issues
or email
.Li j@cgl.sh
